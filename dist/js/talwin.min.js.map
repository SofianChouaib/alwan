{"version":3,"file":"js/talwin.min.js","mappings":"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","sources":["webpack://Talwin/webpack/universalModuleDefinition","webpack://Talwin/webpack/bootstrap","webpack://Talwin/webpack/runtime/define property getters","webpack://Talwin/webpack/runtime/hasOwnProperty shorthand","webpack://Talwin/./src/js/constants.js","webpack://Talwin/./src/js/utils/object.js","webpack://Talwin/./src/js/utils/util.js","webpack://Talwin/./src/js/utils/dom.js","webpack://Talwin/./src/js/defaults.js","webpack://Talwin/./src/js/core/events/EventBinder.js","webpack://Talwin/./src/js/lib/scPop.js","webpack://Talwin/./src/js/lib/svg.js","webpack://Talwin/./src/js/lib/colors.js","webpack://Talwin/./src/js/lib/parser.js","webpack://Talwin/./src/js/core/index.js","webpack://Talwin/./src/js/components/Reference.js","webpack://Talwin/./src/js/components/App.js","webpack://Talwin/./src/js/components/Palette.js","webpack://Talwin/./src/js/components/Marker.js","webpack://Talwin/./src/js/components/Preview.js","webpack://Talwin/./src/js/components/Sliders.js","webpack://Talwin/./src/js/components/Inputs.js","webpack://Talwin/./src/js/components/Swatches.js","webpack://Talwin/./src/js/index.js","webpack://Talwin/./src/js/core/events/EventListener.js","webpack://Talwin/./src/js/core/color.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"Talwin\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"Talwin\"] = factory();\n\telse\n\t\troot[\"Talwin\"] = factory();\n})(self, function() {\nreturn ","// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","export const ROOT = document;\nexport const BODY = ROOT.body;\nexport const HTML = ROOT.documentElement;\n\nexport const BUTTON = 'button';\nexport const SVG = 'svg';\n\nexport const OPEN = 'open';\nexport const CLOSE = 'close';\nexport const COLOR = 'color';\nexport const CLICK = 'click';\nexport const MOUSE_DOWN = 'mousedown';\nexport const MOUSE_MOVE = 'mousemove';\nexport const MOUSE_UP = 'mouseup';\nexport const TOUCH_START = 'touchstart';\nexport const TOUCH_MOVE = 'touchmove';\nexport const TOUCH_END = 'touchend';\nexport const TOUCH_CANCEL = 'touchcancel';\nexport const SCROLL = 'scroll';\nexport const RESIZE = 'resize';\nexport const KEY_DOWN = 'keydown';\nexport const INPUT = 'input';\nexport const CHANGE = 'change';\nexport const MOUSE_LEAVE = 'mouseleave';\nexport const FOCUS_IN = 'focusin';\nexport const FOCUS_OUT = 'focusout';\n\nexport const HEX_FORMAT = 'hex';\nexport const RGB_FORMAT = 'rgb';\nexport const HSL_FORMAT = 'hsl';\nexport const HSV_FORMAT = 'hsv';\n\nexport const TAB = 'Tab';\nexport const ARROW_RIGHT = 'ArrowRight';\nexport const ARROW_LEFT = 'ArrowLeft';\nexport const ARROW_UP = 'ArrowUp';\nexport const ARROW_DOWN = 'ArrowDown';\nexport const ENTER = 'Enter';\nexport const ESCAPE = 'Escape';\n\nexport const FOCUS_CLASSNAME = 'tw-focus';\nexport const BUTTON_CLASSNAME = 'tw-btn';\n\nexport const COLOR_PROPERTY = 'tw-' + COLOR;\n\nexport const REMOVE_METHOD = 'remove';\nexport const ADD_METHOD = 'add';\n\n// Picker supported color formats.\nexport const COLOR_FORMATS = [HEX_FORMAT, RGB_FORMAT, HSL_FORMAT];\n\n\nexport const { max, min, round } = Math;\nexport const float = parseFloat;\nexport const int = parseInt;","/**\n * Iterate in an object, stop and return false if callback function returns true.\n *\n * @param {Object} object - Any object.\n * @param {CallableFunction} fn - Any Callback function.\n * @returns \n */\nexport const objectIterator = (object, fn) => {\n\n    for (const key in object) {\n        if (Object.hasOwnProperty.call(object, key)) {\n            if (fn(object[key], key, object)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\n/**\n * Merges two or more objects together into the target object.\n *\n * @param {Object} target - Object that will receive the new properties.\n * @param  {...Object} sources - Objects containing additional properties to merge in.\n * @returns \n */\nexport const merge = (target, ...sources) => Object.assign(target, ...sources);\n\n/**\n * Checks if two object are equals.\n *\n * @param {Object} object1 - Any object.\n * @param {Object} object2 - Any object.\n * @returns {Boolean}\n */\nexport const isEqual = (object1, object2) => objectIterator(object1, (value, key) => !object2 || object2[key] !== value);\n","import { max, min } from \"../constants\";\n\n/**\n * Checks if a value is a string.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isString = value => typeof value === 'string';\n\n/**\n * Checks if a value is not undefined or null.\n *\n * @param {Any} value - Value.\n * @returns {Boolean}\n */\nexport const isset = value => value != null;\n\n\n/**\n * Bounds a number between a lower bound and an upper bound.\n *\n * @param {number} number - Any number.\n * @param {number} upperBound - Max.\n * @param {number} lowerBound - Min.\n * @returns {number}\n */\nexport const boundNumber = (number, upperBound, lowerBound) => min(max(number, lowerBound || 0), upperBound || 100);","import { ADD_METHOD, BODY, BUTTON, INPUT, REMOVE_METHOD, ROOT, SCROLL, SVG } from \"../constants\";\nimport { objectIterator } from \"./object\";\nimport { isString } from \"./util\";\n\n/**\n * Gets a DOM element.\n *\n * @param {String|Element} ref - CSS selector or DOM element.\n * @param {Element} context - Element to search from.\n * @param {Boolean} all - Get all elements.\n * @returns {Element|null}\n */\nexport const getElement = (ref, context, all) =>\n    isString(ref) ? ref && (context || ROOT)['querySelector' + (all ? 'All' : '')](ref)\n        : ref instanceof Element ? ref\n        : null;\n\n/**\n * Creates a new HTML Element.\n *\n * @param {String}           tagName     - HTML Element's Tag name.\n * @param {String}           className   - HTML Element's class name.\n * @param {Element}          parent - Append the new created element to this element.\n * @param {Object}           data - New element data its attributes, content html or inner text.\n * @param {CallableFunction} callback - Callback.\n * @returns {Element}\n */\nexport const createElement = (tagName, className, parent, data, callback) => {\n\n    data = data || {}\n    const ns = `http://www.w3.org/${tagName === SVG ? '2000/svg' : '1999/xhtml'}`;\n    const element = document.createElementNS(ns, tagName || 'div');\n\n    if (className) {\n        element.className = className;\n    }\n\n    objectIterator(data, (value, key) => {\n        if (key === 'html') {\n            setElementsHTML(element, value);\n        } else if (key === 'text') {\n            element.innerText = value;\n        } else {\n            value && element.setAttributeNS('', key, value);\n        }\n    });\n\n    if (parent) {\n        parent.appendChild(element);\n    }\n\n    callback && callback(element);\n\n    return element;\n}\n\n\n/**\n * Gets element bounds.\n *\n * @param {HTMLElement} el Element.\n * @returns {Object}\n */\nexport const getBounds = (el) => el && el.getBoundingClientRect();\n\n\n/**\n * Gets an element's parent.\n *\n * @param {Element} el - Any html element.\n * @returns {Element}\n */\nexport const getParent = el => el.parentElement;\n\n\n/**\n * Replace a child node with another node.\n *\n * @param {Node} newChild - Any html node.\n * @param {Node} oldChild - Any html node.\n * @returns {Node}\n */\nexport const replaceElement = (newChild, oldChild) => getParent(oldChild).replaceChild(newChild, oldChild) && newChild;\n\n/**\n * Removes an element from the DOM.\n *\n * @param {HTMLElement} element - Any html node.\n * @param {Boolean} destroy - Remove Reference. \n * @returns {Element|null}\n */\nexport const removeElement = (element, destroy) => element && getParent(element).removeChild(element) && (destroy ? null : element);\n\n\n/**\n * Gets any scrollable ancestor of an element.\n * Document is always included.\n *\n * @param {HTMLElement} el - Subject element.\n * @returns {Array}\n */\nexport const getScrollableAncestors = el => {\n    el = getParent(el);\n  \n    let scrollableElements = [ROOT];\n  \n    while (el !== BODY) {\n      let overflow = getComputedStyle(el).overflow;\n      if (overflow === 'auto' || overflow === SCROLL) {\n        scrollableElements.push(el);\n      }\n      el = getParent(el);\n    }\n  \n    return scrollableElements;\n}\n\n\n/**\n * Check if an element is visible in the viewport of all scrollable elements.\n *\n * @param {HTMLElement} el - Any html element.\n * @param {Array} scrollableElements - scrollable elements.\n * @returns {boolean}\n */\nexport const isInViewport = (el, scrollableElements) =>\n    scrollableElements.every(scrollable => {\n        let isVisible = true;\n\n        if (scrollable !== ROOT) {\n            let {top: elTop, bottom: elBottom} = getBounds(el);\n            let {top: scrollableTop, bottom: scrollableBottom} = getBounds(scrollable);\n\n            isVisible = elTop >= scrollableTop && scrollableBottom >= elBottom;\n        }\n\n        return isVisible;\n    });\n\n\n/**\n * Sets a CSS custom property.\n *\n * @param {HTMLElement} el  - Element to set its custom property.\n * @param {string} property - Property name.\n * @param {string} value    - Property value.\n */\nexport const setCustomProperty = (el, property, value) => {\n    el && el.style.setProperty('--' + property, value);\n}\n\n/**\n * Gets the last focusable element in an element (context).\n *\n * @param {Element} context - Element which the last focusable elment is an ancestor.\n * @returns {Element}\n */\nexport const getLastFocusableElement = context => {\n    let focusableElements = getElement(BUTTON + ',' + INPUT, context, true);\n    return focusableElements[focusableElements.length - 1];\n}\n\n/**\n * Hides/Shows element.\n * Truthy value or non empty array shows the element,\n * else hides it.\n * \n * @param {Element} el - Element to show/hide.\n * @param {Array|Boolean} cond - Condition.\n */\nexport const setVisibility = (el, cond) => {\n\n    let length = cond && cond.length;\n\n    if (length != null) {\n        cond = length;\n    }\n\n    el.style.display = cond ? '' : 'none';\n}\n\n/**\n * Adds/Remove class based on a condition.\n *\n * @param {Element} el - Any Element.\n * @param {String} classname - CSS Class Selector.\n * @param {Boolean} cond - Condition.\n */\nexport const updateClass = (el, classname, cond) => {\n    classname && el.classList[cond ? ADD_METHOD : REMOVE_METHOD](classname);\n}\n\n/**\n * Sets element's inner html.\n *\n * @param {Element} el - Any Element.\n * @param {String} html - HTML string.\n */\nexport const setElementsHTML = (el, html) => {\n    el.innerHTML = html || '';\n}","/**\n * SC Picker default options.\n */\n export const defaults = {\n    // Set the container's (widget) id.\n    id: '',\n\n    // One or many classes separated by a white space,\n    // to add it to the preset button.\n    classname: '',\n\n    // Choose a theme, 'dark' or 'light'.\n    theme: 'light',\n\n    // Toggle picker's visibility (Show/Hide),\n    // Setting this to false keeps the picker visible.\n    toggle: true,\n\n    // Display the picker container as a pop-up (a box that floats on top of the page content),\n    // if it's false, picker container will be displayed as a block (embeded in the page's content).\n    popover: true,\n\n    // Set the position of the popper (if popover is set to true) relative to the reference element,\n    // the position has two values seperated by a dash (-),\n    // the first value is the direction (top, bottom, right, left),\n    // the second value is the alignment (start, center, end), omitting this value will default to center.\n    // e.g. 'bottom-start': 'bottom' places the picker below the reference element,\n    // and 'start' aligns the left side of the container with the left side of the reference element.\n    // Note: \n    // If the picker container has no space to be placed, it will auto-position itself.\n    // based on the available space.\n    position: 'bottom-start',\n\n    // Set the gap (in pixels) between the picker container and the reference element.\n    margin: 8,\n\n    // Replace the reference element with a pre-styled button.\n    preset: true,\n\n    // Initial color.\n    color: '#000',\n\n    // Default color.\n    default: '#000',\n\n    // Target can be a selector or an HTML element,\n    // If the option popover is true, the picker container will be positionned retalive to this element,\n    // instead of the reference element.\n    // else if popover option is false, the picker container will be appended as a child into this element.\n    target: '',\n\n    // Disable the picker, users won't be able to pick colors.\n    disabled: false,\n\n    // Initial color format.\n    format: 'rgb',\n\n    // For the formats 'hsl' and 'rgb', choose a single input to display the color string,\n    // or if false, display an input for each color channel.\n    singleInput: false,\n\n    // Choose color formats for the picker input, 'hsl', 'rgb' or 'hex',\n    // No input will be displayed if the array is empty.\n    inputs: {\n        rgb: true,\n        hex: true,\n        hsl: true,\n    },\n\n    // Support alpha channel and display opacity slider.\n    opacity: true,\n\n    // Preview the color.\n    preview: true,\n\n    // Add/Remove a copy button.\n    copy: true,\n\n    // Array of color strings, invalid color strings will default to rgb(0,0,0).\n    swatches: [],\n}","import { ADD_METHOD, REMOVE_METHOD } from \"../../constants\";\nimport { isString } from \"../../utils/util\";\n\n/**\n * Adds/Removes one or more event listeners to/from an element.\n *\n * @param {targetElement} targetElement - Event target element.\n * @param {Array} eventData - Event data (type, handler, options).\n * @param {String} method - Add or Remove event listener method.\n */\nexport const binder = (eventData, unbind) => {\n\n    let method = (unbind ? REMOVE_METHOD: ADD_METHOD) + 'EventListener';\n    let [targetElement, events, handler, options] = eventData;\n\n    // If its a single event then put it inside an array.\n    if (isString(events)) {\n        events = [events];\n    }\n\n    events.forEach(event => {\n        targetElement[method](event, handler, options);\n    });\n}\n\n/**\n * Binds events to an element and stores listener in an array.\n *\n * @param {Array} listeners - Event Listeners.\n * @param {targetElement} targetElement - Event Target.\n * @param {String|Array} events - Event type.\n * @param {CallableFunction} handler - Event handler.\n * @param {Object|Boolean} options - Event options.\n * @returns {Array}\n */\nexport const bindEvent = (listeners, targetElement, events, handler, options) => {\n\n    if (targetElement) {\n        options = options || false;\n        let eventData = [targetElement, events, handler, options];\n        binder(eventData);\n        listeners.push(eventData);\n    }\n\n    return listeners;\n}\n\n/**\n * Unbinds all listeners attach to an element and removes them from listeners array.\n *\n * @param {Array} listeners - Event listeners.\n * @param {targetElement} targetElement - Event Target.\n * @returns {Array}\n */\nexport const unbindEvent = (listeners, targetElement) =>\n    // Filter out listeners attached to this TargetElement.\n    listeners.filter(eventData => \n        targetElement === eventData[0] ? \n            binder(eventData, true)\n            : true\n    );","import { BODY, HTML, max } from \"../constants\";\nimport { getBounds } from \"../utils/dom\";\n\nconst TOP = 1;\nconst RIGHT = 2;\nconst BOTTOM = 3;\nconst LEFT = 4;\nconst START = 5;\nconst CENTER = 6;\nconst END = 7;\n\nconst sides = {\n    top: TOP,\n    right: RIGHT,\n    bottom: BOTTOM,\n    left: LEFT,\n};\n\nconst alignments = {\n    start: START,\n    center: CENTER,\n    end: END,\n};\n\n\n/**\n * Sets popover's position relative to an element.\n *\n * @param {HTMLElement} ref     - Reference element.\n * @param {HTMLElement} pop     - Popper element.\n * @param {Object}      options - Options.\n * @returns {Object}\n */\nexport const scPop = (ref, pop, options) => {\n    /**\n     * SC Pop options.\n     */\n    options = options || {};\n\n    /**\n     * Reference element width.\n     */\n    let refWidth;\n\n    /**\n     * Reference element height.\n     */\n    let refHeight;\n\n    /**\n     * Reference element Left,\n     * X coordinate.\n     */\n    let refLeft;\n\n    /**\n     * Reference element Top,\n     * Y coordinate.\n     */\n    let refTop;\n\n    /**\n     * Reference element Bottom,\n     * Y coordinate + height.\n     */\n    let refBottom;\n\n    /**\n     * Reference element Right,\n     * X coordinate + width.\n     */\n    let refRight;\n\n    /**\n     * Reference element horizontal center,\n     * X coordinate + width / 2.\n     */\n    let refCenterX;\n\n    /**\n     * Reference element vertical center,\n     * Y coordinate + height / 2.\n     */\n    let refCenterY;\n\n    /**\n     * Pop element width.\n     */\n    let popWidth;\n\n    /**\n     * Pop element height.\n     */\n    let popHeight;\n\n    /**\n     * Pop element width with margin.\n     */\n    let popOffsetWidth;\n\n    /**\n     * Pop element height with margin.\n     */\n    let popOffsetHeight;\n\n    /**\n     * Document height.\n     */\n    let docHeight;\n\n    /**\n     * Document width.\n     */\n    let docWidth;\n\n    /**\n     * Pop margin.\n     */\n    let margin = parseFloat(options.margin) || 4;\n\n    /**\n     * Pop position.\n     */\n    let position = options.position ? options.position.split(\"-\") : [];\n\n    /**\n     * Pop position side.\n     */\n    let side = sides[position[0]] || BOTTOM;\n\n    /**\n     * Pop position alignment.\n     */\n    let alignment = position[1] ? alignments[position[1]] || START : CENTER;\n\n    /**\n     * Pop Y coordinate.\n     */\n    let popTop = 0;\n\n    /**\n     * Pop X coordinate.\n     */\n    let popLeft = 0;\n\n    /**\n     * Pop inline CSS object.\n     */\n    let popStyle = pop.style;\n\n    /**\n     * Check if space is available for positioning the pop on the one of the 4 sides.\n     *\n     * @param {Number} side - Position side.\n     * @returns {boolean}\n     */\n    const hasSpaceForSides = side => side === TOP && refTop >= popOffsetHeight ||\n        side === BOTTOM && docHeight - refBottom >= popOffsetHeight ||\n        side === RIGHT && docWidth - refRight >= popOffsetWidth ||\n        side === LEFT && refLeft >= popOffsetWidth;\n\n    /**\n     * Check if space is available for aligning the pop element.\n     *\n     * @param {Number} alignment - Position alignment.\n     * @param {boolean} isVertical - Pop is on the Top side or the Bottom side.\n     * @returns {boolean}\n     */\n    const hasSpaceForAlignment = (alignment, isVertical) => alignment === START ? isVertical ? docWidth - refLeft >= popWidth : docHeight - refTop >= popHeight\n        : alignment === CENTER ? isVertical ? 2 * (docWidth - refCenterX) >= popWidth && refCenterX * 2 >= popWidth : 2 * (docHeight - refCenterY) >= popHeight && refCenterY * 2 >= popHeight\n            : isVertical ? refRight >= popWidth : refBottom >= popHeight;\n\n    /**\n     * Place the pop in one of the 4 sides.\n     *\n     * @param {Number} side - Position side.\n     */\n    const setSide = side => {\n        popTop = side === TOP ? refTop - popOffsetHeight : side === BOTTOM ? refBottom + margin : 0;\n        popLeft = side === RIGHT ? refRight + margin : side === LEFT ? refLeft - popOffsetWidth : 0;\n    }\n\n\n\n    /**\n     * Place the pop in one of the 3 alignments.\n     *\n     * @param {Number} alignment - Position alignment.\n     * @param {boolean} isVertical - Pop is on the Top side or the Bottom side.\n     */\n    const setAlignment = (alignment, isVertical) => {\n        if (alignment === START) {\n            isVertical ? popLeft = refLeft : popTop = refTop;\n        } else if (alignment === CENTER) {\n            isVertical ? popLeft = refLeft - popWidth / 2 + refWidth / 2 : popTop = refTop - popHeight / 2 + refHeight / 2;\n        } else {\n            isVertical ? popLeft = refRight - popWidth : popTop = refBottom - popHeight;\n        }\n    }\n\n    /**\n     * Center the pop element vertically to the screen.\n     */\n    const centerPopVertically = () => (docHeight - popHeight) / 2;\n\n    /**\n     * Center the pop element horizontally to the screen.\n     */\n    const centerPopHorizontally = () => (docWidth - popWidth) / 2;\n\n    /**\n     * Fallback positions order.\n     */\n    const fallbacksPositions = {\n        /**\n         * Sides to fallback to.\n         */\n        [TOP]: [TOP, BOTTOM, RIGHT, LEFT],\n        [BOTTOM]: [BOTTOM, TOP, RIGHT, LEFT],\n        [RIGHT]: [RIGHT, LEFT, TOP, BOTTOM],\n        [LEFT]: [LEFT, RIGHT, TOP, BOTTOM],\n        /**\n         * Alignments to fallback to.\n         */\n        [START]: [START, CENTER, END],\n        [CENTER]: [CENTER, START, END],\n        [END]: [END, CENTER, START],\n    };\n\n    /**\n     * Position the pop element.\n     */\n    const setPosition = () => {\n\n        ({\n            width: refWidth,\n            height: refHeight,\n            top: refTop,\n            right: refRight,\n            bottom: refBottom,\n            left: refLeft,\n        } = getBounds(ref));\n\n        // Cash the ref center coordinates.\n        refCenterX = refLeft + refWidth / 2;\n        refCenterY = refTop + refHeight / 2;\n\n        // Pop bounds.\n        ({ width: popWidth, height: popHeight } = getBounds(pop));\n\n        popOffsetWidth = popWidth + margin;\n        popOffsetHeight = popHeight + margin;\n\n        // Document dimensions.\n        let docBounds = getBounds(HTML);\n        docWidth = docBounds.width;\n        docHeight = max(HTML.clientHeight, docBounds.height, getBounds(BODY).height);\n\n        // Reference sides to use.\n        let sidesArray = fallbacksPositions[side],\n            positionSide,\n            sideIsSet = false,\n            alignmentIsSet = false;\n\n        let i = 0;\n        while (i < sidesArray.length && !sideIsSet) {\n            positionSide = sidesArray[i];\n\n            if (hasSpaceForSides(positionSide)) {\n                // Set the position.\n                setSide(positionSide);\n                sideIsSet = true;\n            }\n\n            i++;\n        }\n\n        // The pop is successfully placed in one of the 4 sides.\n        if (sideIsSet) {\n            let alignmentsArray = fallbacksPositions[alignment];\n            let isVertical = positionSide === TOP || positionSide === BOTTOM;\n            let j = 0;\n            // Check the alignments.\n            while (j < alignmentsArray.length && !alignmentIsSet) {\n                const positionAlignment = alignmentsArray[j];\n\n                if (hasSpaceForAlignment(positionAlignment, isVertical)) {\n                    // Set the alignment position.\n                    setAlignment(positionAlignment, isVertical);\n                    alignmentIsSet = true;\n                }\n\n                j++;\n            }\n\n            // Center the element to the screen if all alignments fail.\n            if (!alignmentIsSet) {\n                isVertical ? popLeft = centerPopHorizontally() : popTop = centerPopVertically();\n            }\n        } else {\n            // Pop has no space to fit in in all 4 sides.\n            // Center the pop vertically and horizontally to the screen.\n            popTop = centerPopVertically();\n            popLeft = centerPopHorizontally();\n        }\n\n        popStyle.top = popTop + 'px';\n        popStyle.left = popLeft +'px';\n    }\n\n    setPosition();\n\n    return {\n        update: setPosition\n    }\n}","import { merge } from \"../utils/object\";\n\nconst svgStaticAttrs = {\n    'aria-role': 'none',\n    focusable: 'false'\n}\n\nconst svgAttrs = (width, height, viewBox, html) => ({ width, height, viewBox, html });\n\nconst clipboardSVG = '<path d=\"M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z\"></path>';\nconst checkSVG = '<path d=\"M9,20.42L2.79,14.21L5.62,11.38L9,14.77L18.88,4.88L21.71,7.71L9,20.42Z\"></path>';\nconst switchSVG = '<path d=\"M10 1L5 8h10l-5-7zm0 18l5-7H5l5 7z\"></path>';\n\nexport const clipboardSVGAttrs = merge(svgAttrs('18', '18', '0 0 24 24', clipboardSVG), svgStaticAttrs);\nexport const checkSVGAttrs = merge(svgAttrs('18', '18', '0 0 24 24', checkSVG), svgStaticAttrs);\nexport const switchSVGAttrs = merge(svgAttrs('15', '15', '0 0 20 20', switchSVG), svgStaticAttrs);","import { HSL_FORMAT, int, max, min, round } from \"../constants\";\nimport { isString } from \"../utils/util\";\n\n/**\n * Convert HSV to RGB.\n *\n * @param {Object} hsv - HSV color object.\n * @returns {Object}\n */\nexport const HSVToRGB = hsv => {\n\n    let H = hsv.h / 60,\n        S = hsv.s,\n        V = hsv.v;\n\n    /**\n     * Helper function used for converting HSV to RGB.\n     *\n     * @param {Number} k - Positive Coefficient.\n     * @param {Number} s - hSV Saturation.\n     * @param {Number} v - HSV Value.\n     * @returns {Number}\n     */\n    let fn = (k, s, v) => (v - v * s * max(0, min(k, 4 - k, 1))) * 255;\n\n    return {\n        r: round(fn((5 + H) % 6, S, V)),\n        g: round(fn((3 + H) % 6, S, V)),\n        b: round(fn((1 + H) % 6, S, V)),\n        a: hsv.a\n    }\n}\n\n\n/**\n * Convert RGB or HSL color objects to string.\n *\n * @param {Object} color  - Color Object.\n * @param {string} format - Color format.\n * @returns {string}\n */\nexport const toString = (color, format) => {\n\n    let colorString = color;\n\n\tif (! isString(color)) {\n\n        let a = '',\n            opacity = '',\n            comma = ', ';\n    \n        if (color.a < 1) {\n            a = 'a';\n            opacity = comma + color.a;\n        }\n\n        let percent = format === HSL_FORMAT ? '%' : '';\n\t\tcolorString = format + a + '(' + color[format[0]] + comma + color[format[1]] + percent + comma + color[format[2]] + percent + opacity + ')';\n\t}\n\n    return colorString;\n}\n\n/**\n * Converts hex color string to RGB color object.\n *\n * @param {string} hexColor - Hexadecimal color string.\n * @returns {Object}\n */\nexport const HEXToRGB = hexColor => ({\n    r: int(hexColor.slice(1, 3), 16),\n    g: int(hexColor.slice(3, 5), 16),\n    b: int(hexColor.slice(5, 7), 16),\n    a: 1\n});\n\n\n/**\n * Converts a decimal number to hexadecimal number.\n * The result must be two digits.\n *\n * @param {Number} number Decimal number.\n * @returns {string}\n */\nconst toHex = number => {\n\tlet hexNumber = number.toString(16);\n\treturn hexNumber.length < 2 ? '0' + hexNumber : hexNumber;\n}\n\n\n/**\n * Converts RGB color object to Hex string color.\n *\n * @param {Object} rgb - RGB color object.\n * @returns {String}\n */\nexport const RGBToHEX = ({ r, g, b, a }) => '#' + toHex(r) + toHex(g) + toHex(b) + (a < 1 ? toHex(round(a * 255)) : '');\n\n\n/**\n * Converts HSV to HSL.\n *\n * @param {Object} hsv - HSV color object.\n * @returns {Object}\n */\nexport const HSVToHSL = (hsv, percentage) => {\n\n    percentage = percentage ? '%' : 0;\n\n    let v = hsv.v;\n    let l = v * (1 - hsv.s / 2);\n    let s = ! l || l === 1 ? 0 : (v - l) / min(l, 1 - l);\n\n    return {\n        h: hsv.h,\n        s: round(s * 100) + percentage,\n        l: round(l * 100) + percentage,\n        a: round(hsv.a * 100) / 100\n    }\n}\n\n/**\n * Converts HSL to HSV.\n *\n * @param {Object} hsl - HSL color object.\n * @returns {Object}\n */\nexport const HSLToHSV = (hsl) => {\n\tlet s = hsl.s / 100,\n\t\tl = hsl.l / 100,\n\t\tv = l + s * min(l, 1 - l);\n\t\n\treturn {\n\t\th: hsl.h,\n\t\ts: v ? 2 * (1 - l / v) : 0,\n\t\tv,\n\t\ta: hsl.a\n\t}\n}\n\n\n/**\n * Converts RGB to HSV.\n *\n * @param {Object} rgb - RGB color object.\n * @returns {Object}\n */\nexport const RGBToHSV = rgb => {\n\tlet R = rgb.r / 255,\n\t\tG = rgb.g / 255,\n\t\tB = rgb.b / 255,\n\t\tCmax = max(R, G, B),\n\t\tCmin = min(R, G, B),\n\t\trange = Cmax - Cmin,\n\t\tsaturation = Cmax === 0 ? 0 : range / Cmax,\n\t\thue = range === 0 ? 0\n            : Cmax === R ? ((G - B) / range) % 6\n            : Cmax === G ? ((B - R) / range) + 2\n            : Cmax === B ? ((R - G) / range) + 4\n            : 0;\n\n\treturn {\n\t\th: round( ( 360 + hue * 60 ) % 360 ),\n\t\ts: saturation,\n\t\tv: Cmax,\n\t\ta: round( rgb.a * 100 ) / 100\n\t}\n}","import { float, HSL_FORMAT, RGB_FORMAT, round } from \"../constants\";\nimport { createElement } from \"../utils/dom\";\nimport { boundNumber } from \"../utils/util\";\nimport { HEXToRGB, toString } from \"./colors\";\n\nconst ctx = createElement('canvas').getContext('2d');\nconst HSL_REGEX = /^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(\\w*)?(?:(?:\\s+([+-]?\\d*\\.?\\d+)%\\s*([+-]?\\d*\\.?\\d+)%(?:\\s*\\/\\s*([+-]?\\d*\\.?\\d+%?))?)|(?:\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%(?:\\s*,\\s*([+-]?\\d*\\.?\\d+%?))?))\\s*\\)?$/i;\nconst HEX_REGEX = /^#[0-9a-f]{6}$/i;\n\n\n/**\n * Parses a color string.\n *\n * @param {String} colorString - Color string.\n * @param {Boolean} asString - Return color as a string or object.\n * @returns {Object}\n */\nexport const parseColor = (colorString, asString) => {\n\n    let color;\n    let format;\n\n    colorString = colorString.trim();\n    /**\n     * Parse hsl.\n     * No need to parse it if it's shorter than the minimum hsl string length,\n     * the minimum is 10 characters, e.g. hsl(0 0%0%.\n     */\n    if (colorString.length >= 10) {\n\n        const channels = colorString.match(HSL_REGEX);\n\n        if (channels) {\n            let h = float(channels[1]),\n                angle = channels[2],\n                s = boundNumber(channels[3] || channels[6]),\n                l = boundNumber(channels[4] || channels[7]),\n                a = channels[5] || channels[8];\n\n            /**\n             * The hue value is so often given in degrees, it can be given as a number, however\n             * it might has a unit 'turn', 'rad' (radians) or 'grad' (gradians),\n             * If the hue has a unit other than deg, then convert it to degrees.\n             */\n            h *= angle === 'turn' ? 360\n                : angle === 'rad' ? 180 / PI\n                : angle === 'grad' ? 0.9\n                : 1;\n\n            // Make sure hue is between 0 and 360.\n            let maxAngle = 360;\n            h = (round(h) % maxAngle + maxAngle) % maxAngle;\n\n            // Alpha value must be between 0 and 1.\n            a = a ? boundNumber(a.slice(-1) === '%' ? float(a) / 100 : a, 1) : 1;\n\n            color  = { h, s, l, a };\n            format = HSL_FORMAT;\n        }\n    }\n\n\t// colorString is not an HSL string.\n\tif (! color) {\n\n\t\tctx.fillStyle = '#000';\n\t\tctx.fillStyle = colorString;\n\t\tcolorString = ctx.fillStyle;\n\t\t// ColorString is either hex or rgb string,\n\t\t// if it's hex convert it to rgb object,\n\t\t// if it's rgb then parse it to object.\n\t\tif (HEX_REGEX.test(colorString)) {\n\t\t\tcolor = HEXToRGB(colorString);\n\t\t} else {\n            // Parse RGB string.\n            let [r, g, b, a] = colorString.match(/\\((.+)\\)/)[1]\n                                          .split(',')\n                                          .map(value => float(value));\n\n            color = {\n                r,\n                g,\n                b,\n                a: a ? round(a * 100) / 100 : 1,\n            }\n        }\n\n        format = RGB_FORMAT;\n    }\n\n    return asString ? toString(color, format) : { c: color, f: format };\n}","import { App } from \"../components/App\";\nimport { Inputs } from \"../components/Inputs\";\nimport { Palette } from \"../components/Palette\";\nimport { Preview } from \"../components/Preview\";\nimport { Reference } from \"../components/Reference\";\nimport { Sliders } from \"../components/Sliders\";\nimport { Swatches } from \"../components/Swatches\";\nimport { createElement } from \"../utils/dom\";\nimport { merge, objectIterator } from \"../utils/object\";\n\n\nconst CONTAINER_CLASSNAME = 'talwin__container';\n\n/**\n * Create and initialize components.\n *\n * @param {Element} reference - Picker Reference element.\n * @param {Object} talwin - Talwin Instance.\n * @returns {Object}\n */\nexport const createComponents = (reference, talwin) => {\n\n    /**\n     * Creates a container element.\n     *\n     * @param {HTMLElement} parent - Element to append the created container to.\n     * @returns {HTMLElement}\n     */\n    const createContainer = (parent) => createElement('', CONTAINER_CLASSNAME, parent);\n\n\n    let ref = Reference(reference, talwin);\n    let app = App(talwin);\n\n    let root = app.$;\n\n    let palette = Palette(root, talwin);\n\n    let container = createContainer(root);\n    \n    let preview = Preview(container, talwin);\n    let sliders = Sliders(container, talwin);\n    let inputs = Inputs(createContainer(root), talwin);\n    let swatches = Swatches(root, talwin);\n\n    return {\n        ref,\n        app,\n        palette,\n        preview,\n        sliders,\n        inputs,\n        swatches\n    }\n}\n\n/**\n * Initialize components.\n *\n * @param {Object} talwin - Instance.\n * @param {Object} options - Talwin options.\n */\nexport const initialize = (talwin, options) => {\n\n    options = options || {};\n\n    let config = talwin.config;\n    let color = options.color;\n\n    merge(config, options);\n\n    objectIterator(talwin._ui, component => {\n        let init = component.init;\n\n        if (init) {\n            init(config);\n        }\n    });\n\n    /**\n     * Initialize color.\n     */\n    if (color) {\n        talwin.setColor(color);\n    }\n}","import { BUTTON, CLICK } from \"../constants\";\nimport { bindEvent, unbindEvent } from \"../core/events/EventBinder\";\nimport { createElement, replaceElement, setVisibility, updateClass } from \"../utils/dom\";\n\n\nconst PRESET_BUTTON_CLASSNAME = 'tw-ref';\n\n/**\n * Creates a Reference component.\n *\n * @param {Element} originalRef - User Reference Element.\n * @returns {Object}\n */\nexport const Reference = (originalRef, talwin) => {\n\n    /**\n     * Reference API.\n     */\n    const self = {\n        $: originalRef,\n        /**\n         * Reference Events.\n         */\n        e: [],\n        /**\n         * Sets/Unsets the pre-styled button.\n         *\n         * @param {Object} options - Picker options.\n         */\n        init(options) {\n            let { preset, classname } = options;\n            let { $: ref, e: events } = self;\n\n            events = unbindEvent(events, ref);\n            \n            if (preset !== (ref !== originalRef)) {\n                ref = preset ?\n                        // Replace the user provided reference element with a preset button.\n                        replaceElement( createElement(BUTTON, PRESET_BUTTON_CLASSNAME, null, { type: BUTTON, id: originalRef.id }), originalRef)\n                        // Set back user reference element.\n                        : replaceElement(originalRef, ref);\n            }\n\n            // Add classes in the reference element.\n            if (classname) {\n                classname.split(/\\s+/).map(cls => { updateClass(ref, cls, true) });\n            }\n\n            // Add click event to reference.\n            bindEvent(events, ref, CLICK, togglePicker);\n            self.$ = ref;\n            self.e = events;\n        }\n    }\n\n    /**\n     * Toggle picker.\n     *\n     * @param {Event} e - Click.\n     */\n    const togglePicker = e => {\n        talwin.toggle();\n    }\n\n    return self;\n}","import { BODY, CLOSE, ESCAPE, KEY_DOWN, MOUSE_DOWN, OPEN, RESIZE, ROOT, SCROLL, TAB } from \"../constants\";\nimport { bindEvent, unbindEvent } from \"../core/events/EventBinder\";\nimport { scPop } from \"../lib/scPop\";\nimport { createElement, getElement, getLastFocusableElement, getScrollableAncestors, isInViewport, setVisibility, updateClass } from \"../utils/dom\";\nimport { merge } from \"../utils/object\";\n/**\n * App component constants.\n */\nconst TALWIN_CLASSNAME = 'talwin';\nconst POPPER_CLASSNAME = 'tw-popper';\nconst DISABLED_CLASSNAME = 'tw-disabled';\n\n\n/**\n * App component.\n *\n * @param {Object} talwin - Talwin Instance.\n * @returns {Object}\n */\nexport const App = (talwin) => {\n\n    let { config, _e: { emit }, _clr: colorState } = talwin;\n\n    /**\n     * Top container.\n     *\n     * @type {HTMLElement}\n     */\n    let root = createElement('', TALWIN_CLASSNAME, BODY);\n\n    /**\n     * App API.\n     */\n    let self = {\n        e: []\n    }\n\n    /**\n     * Picker visibility state.\n     */\n    let _isOpen = false;\n\n    /**\n     * Reference element scrollable ancestors.\n     *\n     * @type {Array<Element>}\n     */\n    let scrollableAncestors = [];\n\n    /**\n     * Popper object.\n     *\n     * @type {Object}\n     */\n    let popper;\n\n    /**\n     * Initializes app component.\n     *\n     * @param {Object} options - Talwin options.\n     */\n    const init = (options) => {\n        let { theme, popover, target, position, margin, disabled, id, toggle } = options;\n        let refElement = talwin._ui.ref.$;\n        let targetElement = getElement(target);\n        let targetReference = targetElement || refElement;\n\n        if (id) {\n            root.id = id;\n        }\n        // Remove all popper events.\n        popperEvents(unbindEvent);\n\n        /**\n         * Set disable.\n         */\n        disable(disabled);\n\n        /**\n         * Set Theme.\n         */\n        root.dataset.theme = theme;\n\n        /**\n         * Set Popper.\n         */\n        if (popover) {\n            self.popper = popper = scPop(targetReference, root, {\n                position,\n                margin\n            });\n            // If reference element inside a nested scrollable elements,\n            // get all those scrollable elements in an array.\n            scrollableAncestors = getScrollableAncestors(refElement);\n\n            // Attach scroll event to all scrollable ancestors of the reference element,\n            // in order to update the popper's position.\n            // On window resize reposition the popper.\n            popperEvents(bindEvent);\n        } else {\n            targetReference.insertAdjacentElement( (targetElement ? 'before' : 'after') + 'end', root);\n        }\n        // If it's popover then the method will be 'add', if it's not,\n        // then the method will be 'remove'.\n        updateClass(root, POPPER_CLASSNAME, popover);\n\n        // Toggle option is false, picker is always open.\n        if (! toggle) {\n            open(true);\n        }\n\n        setVisibility(refElement, popover || toggle);\n    }\n\n\n    /**\n     * Update popper's position.\n     *\n     * @param {Event} e - Scroll or Resize event.\n     */\n    const updatePopper = e => {\n        if (_isOpen) {\n            reposition();\n\n            // Close picker if the reference element is not visible in the viewport,\n            // of nested scrollable elements.\n            if (! isInViewport(talwin._ui.ref.$, scrollableAncestors)) {\n                close(true);\n            }\n        }\n    }\n\n    /**\n     * Binds/Unbinds events for updating the popper's position.\n     *\n     * @param {Function} eventBinder - Bind/Unbind events.\n     */\n    const popperEvents = (eventBinder) => {\n        let listeners = self.e;\n\n        scrollableAncestors.forEach(scrollable => {\n            listeners = eventBinder(listeners, scrollable, SCROLL, updatePopper);\n        });\n\n        // On window resize reposition the popper.\n        listeners = eventBinder(listeners, window, RESIZE, updatePopper);\n        listeners = eventBinder(listeners, ROOT, [MOUSE_DOWN, KEY_DOWN], handlesAccessibility);\n\n        self.e = listeners;\n    }\n\n    /**\n     * Hanldes accessibility.\n     * \n     * If picker is displayed as a popover,\n     * send focus from reference element to the picker and vice versa,\n     * close picker on Escape key press or click away from the picker or the reference element.\n     *\n     * @param {Event}\n     */\n    const handlesAccessibility = e => {\n\n        if (_isOpen) {\n\n            let { target, type, key, shiftKey } = e;\n            let components = talwin._ui;\n            let refElement = components.ref.$;\n            let palette = components.palette.$;\n            let elementToFocus;\n            // Clicking outside the picker or pressing Escape key, results in,\n            // closing the picker.\n            if (key === ESCAPE || (type === MOUSE_DOWN && refElement !== target && ! root.contains(target))) {\n                close();\n            } else if (key === TAB) {\n                // Pressing Tab on reference element sends focus to the picker palette.\n                if (target === refElement && !shiftKey) {\n                    elementToFocus = palette;\n                // If picker is displayed as a popover,\n                // Pressing Tab + shift on the palette,\n                // or pressing Tab on the last focusable element in the picker,\n                // sends the focus back to the reference element.\n                } else if ((! shiftKey && target === getLastFocusableElement(root)) || (target === palette && shiftKey)) {\n                    elementToFocus = refElement;\n                }\n\n                if (elementToFocus) {\n                    e.preventDefault();\n                    elementToFocus.focus();\n                }\n            }\n        }\n    }\n\n\n    /**\n     * Repositions popper.\n     */\n    const reposition = () => {\n        popper && popper.update();\n    }\n\n\n    /**\n     * Opens the color picker.\n     *\n     * @param {Boolean} silent - Whether to trigger the open event or not.\n     */\n    const open = (silent) => {\n        if (! _isOpen && ! config.disabled) {\n            // Update inptus.\n            colorState.update({}, true);\n            reposition();\n            // Add open class.\n            updateClass(root, OPEN, true);\n            _isOpen = true;\n            ! silent && emit(OPEN);\n        }\n    }\n\n    /**\n     * Closes the color picker.\n     *\n     * @param {Boolean} silent - Whether to trigger the close event or not.\n     */\n    const close = (silent) => {\n        if (_isOpen && config.toggle) {\n            // Remove open class.\n            updateClass(root, OPEN, false);\n            _isOpen = false;\n            ! silent && emit(CLOSE);\n        }\n    }\n\n    /**\n     * Toggles (opens/closes) the color picker.\n     */\n    const toggle = () => {\n        _isOpen ? close() : open();\n    }\n\n    /**\n     * Gets the state of the picker, opened or closed.\n     *\n     * @returns {Boolean}\n     */\n    const isOpen = () => _isOpen;\n\n    /**\n     * Disable/Enable Picker.\n     *\n     * @param {Boolean} state - Picker state disabled (true) or enabled (false).\n     */\n    const disable = state => {\n        config.disabled = state;\n        state && close(true);\n        // Add/Remove disable class.\n        updateClass(talwin._ui.ref.$, DISABLED_CLASSNAME, state);\n    }\n\n    return merge(self, {\n        $: root,\n        init,\n        isOpen,\n        open,\n        close,\n        toggle,\n        disable,\n        reposition,\n    });\n}","import { ARROW_DOWN, ARROW_LEFT, ARROW_RIGHT, ARROW_UP, COLOR, FOCUS_CLASSNAME, FOCUS_IN, FOCUS_OUT, KEY_DOWN, MOUSE_DOWN, MOUSE_MOVE, MOUSE_UP, ROOT, TOUCH_CANCEL, TOUCH_END, TOUCH_MOVE, TOUCH_START } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { createElement, getBounds, setVisibility, updateClass } from \"../utils/dom\"\nimport { Marker } from \"./Marker\";\n\n/**\n * Palette component constants.\n */\nconst PALETTE_CLASSNAME = 'talwin__palette';\nconst OVERLAY_CLASSNAME = 'tw-overlay';\n\n/**\n * Picker palette.\n *\n * @param {Element} parent - Element to append the palette element to.\n * @param {Object} talwin - Talwin instance.\n * @returns {Object}\n */\nexport const Palette = (parent, talwin) => {\n\n    const { _clr: colorState, _e: { emit }} = talwin;\n\n    /**\n     * Palette element.\n     */\n    const el = createElement('', PALETTE_CLASSNAME, parent, { tabindex: '0' });\n\n    /**\n     * Overlay element, used to set focus only on palette,\n     * if marker is moving.\n     */\n    const overlay = createElement('', OVERLAY_CLASSNAME, parent);\n    setVisibility(overlay, false);\n\n    /**\n     * Marker component.\n     */\n    const marker = Marker(el);\n\n    /**\n     * Palette dimensions\n     */\n    const { width: WIDTH, height: HEIGHT } = getBounds(el);\n\n    /**\n     * Amount of pixel to move marker horizontally using keyboard.\n     */\n    const stepX = WIDTH / 100;\n\n    /**\n     * Amount of pixel to move marker vertically using keyboard.\n     */\n    const stepY = HEIGHT / 100;\n\n    /**\n     * Move marker one step horizontally using keyboard.\n     */\n    const moveX = {\n        [ARROW_RIGHT]: stepX,\n        [ARROW_LEFT]: -stepX\n    }\n\n    /**\n     * Move marker one step vertically using keyboard.\n     */\n    const moveY = {\n        [ARROW_UP]: -stepY,\n        [ARROW_DOWN]: stepY\n    }\n\n    /**\n     * Palette event listeners.\n     */\n    let listeners = [];\n\n    /**\n     * Palette element bounds.\n     */\n    let bounds;\n\n    /**\n     * State of the palette.\n     */\n    let isDragging = false;\n\n    /**\n     * Marker start moving.\n     *\n     * @param {Event} e - Mousedown or Touchstart events.\n     * @returns {void}\n     */\n    const dragStart = e => {\n        if (e.touches && e.touches.length > 1) {\n\t\t\treturn;\n\t\t}\n        // Save color state.\n        colorState.start();\n        // Cache palette's bounds.\n        bounds = getBounds(el);\n        moveAndUpdateColor(e);\n        isDragging = true;\n        // Display overlay.\n        setVisibility(overlay, isDragging);\n        el.focus();\n    }\n\n    /**\n     * Moves the marker.\n     *\n     * @param {Event} e - Mousemove or Touchmove event.\n     * @returns {void}\n     */\n    const dragMove = e => {\n        if (!isDragging || (e.touches && e.touches.length > 1)) {\n\t\t\treturn;\n\t\t}\n        moveAndUpdateColor(e);\n    }\n\n\n    /**\n     * Marker stop moving.\n     *\n     * @param {Event} e - Mouseup or Touchend or touchcancel events.\n     */\n    const dragEnd = e => {\n        if (isDragging) {\n            // Trigger change event if color changes.\n            colorState.end(el);\n            isDragging = false;\n            // Hide overlay.\n            setVisibility(overlay, isDragging);\n        }\n    }\n\n\n    /**\n     * Updates color and moves marker.\n     *\n     * @param {Number} x - X coordinate.\n     * @param {Number} y - Y coordinate.\n     */\n    const updateColor = (x, y) => {\n        marker.moveTo(x, y);\n        colorState.update({ s: x / WIDTH, v: 1 - y / HEIGHT });\n        emit(COLOR, colorState.value, el);\n    }\n\n\n    /**\n     * Moves Marker and Updates color.\n     *\n     * @param {Event} e - Drag start or drag move events.\n     */\n    const moveAndUpdateColor = e => {\n        let { top, left } = bounds;\n        let x, y;\n        let touches = e.touches;\n\n        e.preventDefault();\n\n        if (touches) {\n            e = touches[0];\n        }\n\n        // Calculate the local coordinates,\n        // local to the palette.\n        x = e.clientX - left;\n        y = e.clientY - top;\n\n        // Make sure x and y don't go out of bounds.\n\t\tx = x < 0 ? 0 : x > WIDTH ? WIDTH : x;\n\t\ty = y < 0 ? 0 : y > HEIGHT ? HEIGHT : y;\n\n        updateColor(x, y);\n    }\n\n    /**\n     * Updates palette.\n     *\n     * @param {Object} hsv - HSV color object.\n     */\n    const update = hsv => {\n        marker.moveTo(hsv.s * WIDTH, (1 - hsv.v) * HEIGHT);\n    }\n\n    /**\n     * Handles palette's focus.\n     *\n     * @param {Event} e - Focusout or Focusin.\n     */\n    const handleFocus = e => {\n        // Update class condition removes class if its false,\n        // add class if true.\n        let cond = false;\n        // If palette lose focus, remove the focus class,\n        // and remove browser keyboard focus.\n        if (e.type === FOCUS_OUT) {\n            el.blur();\n        } else {\n            cond = ! isDragging;\n        }\n\n        updateClass(el, FOCUS_CLASSNAME, cond);\n    }\n\n    /**\n     * Handles picking color using keyboard.\n     *\n     * @param {Event} e - Keydown.\n     */\n    const handleKeyboard = e => {\n\n        // Add focus class.\n        updateClass(el, FOCUS_CLASSNAME, true);\n\n        let key = e.key;\n\n        if (moveX[key] || moveY[key]) {\n\n            e.preventDefault();\n            let {x, y} = marker.point();\n            let markerX = x, markerY = y;\n\n            x += moveX[key] || 0;\n            y += moveY[key] || 0;\n\n            // Make sure x and y don't go out of bounds.\n            x = x > WIDTH ? WIDTH : x < 0 ? 0 : x;\n            y = y > HEIGHT ? HEIGHT : y < 0 ? 0 : y;\n\n            // If the marker changes its position then calculate and set the color.\n            if (x !== markerX || y !== markerY) {\n                updateColor(x, y);\n            }\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    bindEvent(listeners, el, [MOUSE_DOWN, TOUCH_START], dragStart);\n    bindEvent(listeners, ROOT, [MOUSE_MOVE, TOUCH_MOVE], dragMove, { passive: false });\n    bindEvent(listeners, ROOT, [MOUSE_UP, TOUCH_END, TOUCH_CANCEL], dragEnd);\n    bindEvent(listeners, el, [FOCUS_OUT, FOCUS_IN], handleFocus);\n    bindEvent(listeners, el, KEY_DOWN, handleKeyboard);\n\n    return {\n        $: el,\n        marker,\n        update,\n        e: listeners\n    }\n}","import { createElement, getBounds } from \"../utils/dom\";\n\n\nconst MARKER_CLASSNAME = 'talwin__marker';\n\n/**\n * Palette's marker.\n *\n * @param {HTMLElement} parent - Element to append to.\n * @returns {Object}\n */\nexport const Marker = parent => {\n\n    /**\n     * Marker.\n     */\n    const el = createElement('', MARKER_CLASSNAME, parent);\n\n    \n    const { width, height } = getBounds(el);\n    /**\n     * Cache center X coordinate.\n     */\n    let centerX = width / 2 - 1;\n\n    /**\n     * Cache center Y coordinate.\n     */\n    let centerY = height / 2 - 1;\n\n    /**\n     * Marker X coordinate.\n     */\n    let markerX = 0;\n\n    /**\n     * Marker Y coordinate.\n     */\n    let markerY = 0;\n\n    /**\n     * Moves marker to the x, y coordinates.\n     *\n     * @param {Number} x - X coordinate.\n     * @param {Number} y - Y coordinate.\n     */\n    const moveTo = (x, y) => {\n        markerX = x;\n        markerY = y;\n        el.style.transform = `translate(${x - centerX}px, ${y - centerY}px)`;\n    }\n\n    /**\n     * Gets marker coordinates.\n     *\n     * @returns {Object}\n     */\n    const point = () => ({ x: markerX, y: markerY });\n\n\n    return {\n        $: el,\n        moveTo,\n        point\n    }\n}","import { BUTTON, BUTTON_CLASSNAME, CLICK, FOCUS_CLASSNAME, FOCUS_IN, FOCUS_OUT, MOUSE_LEAVE, SVG } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { checkSVGAttrs, clipboardSVGAttrs } from \"../lib/svg\";\nimport { createElement, removeElement, setElementsHTML, setVisibility, updateClass } from \"../utils/dom\";\n\nconst PREVIEW_CLASSNAME = 'talwin__preview';\n\n/**\n * Preview component.\n *\n * @param {Element} parent - Element to append preview are to.\n * @param {Object} talwin - Instance.\n * @returns {Object}\n */\nexport const Preview = (parent, talwin) => {\n\n    /**\n     * Copy state.\n     */\n    let isCopied = false;\n\n    /**\n     * Preview area wrapper element.\n     */\n    const container = createElement('', 'tw-mr', parent);\n\n    /**\n     * Preview API.\n     */\n    const self = {\n        /**\n         * Preview events.\n         */\n        e: [],\n\n        /**\n         * Init. Preview, copy button.\n         *\n         * @param {Object} options - Picker options.\n         */\n        init(options) {\n            let { preview, copy } = options;\n            let previewArea = self.$;\n            let copyButton = self.cp;\n\n            // Either preview option is true and previewArea doen't exist,\n            // or preview option is false and previewArea does exist.\n            if (preview !== !!previewArea) {\n\n                previewArea = preview ? createElement('', PREVIEW_CLASSNAME, container) : removeElement(previewArea, true);\n    \n                if (copy && copyButton) {\n                    (previewArea || container).appendChild(copyButton);\n                }\n            }\n\n            if (! copy) {\n                copyButton = removeElement(copyButton, true);\n            } else if (! copyButton) {\n                copyButton = createElement(BUTTON, BUTTON_CLASSNAME, previewArea || container, { type: BUTTON }, thisButton => {\n                    updateSVG(thisButton);\n                });\n            }\n\n            // Hide container if both copyButton and previewArea don't exist,\n            setVisibility(container, copyButton || previewArea);\n\n            self.$ = previewArea;\n            self.cp = copyButton;\n        }\n    }\n\n\n    /**\n     * Sets a SVG icon for the copy button.\n     *\n     * @param {HTMLElement} button - Button.\n     */\n    const updateSVG = (button) => {\n        button = button || self.cp;\n        // Remove button content.\n        setElementsHTML(button);\n        createElement(SVG, '', button, isCopied ? checkSVGAttrs : clipboardSVGAttrs);\n    }\n\n    /**\n     * Copies selected color to the clipboard then updates copy,\n     * button's Icon and styles.\n     *\n     * @param {Event} e - Click or Focusin or Focusout or Mouseleave.\n     */\n    const copyColorAndUpdateView = e => {\n        if (self.cp && ! talwin.config.disabled) {\n            let type = e.type;\n            let isFocusIn = type === FOCUS_IN;\n\n            // On click copy color and update svg to display a Check icon.\n            if (! isCopied && type === CLICK) {\n                isCopied = talwin._clr.copy();\n                updateSVG();\n            }else {\n                // On focus add a focus class.\n                if (! isFocusIn) {\n                    // If the copy button lose focus or mouse leaves it,\n                    // then reset the svg to a Clipboard icon.\n                    if (isCopied) {\n                        isCopied = false;\n                        updateSVG();\n                    }\n                }\n\n                updateClass(self.cp, FOCUS_CLASSNAME, isFocusIn);\n            }\n        }\n    }\n\n    /**\n     * Events binding.\n     */\n    bindEvent(self.e, container, [CLICK, MOUSE_LEAVE, FOCUS_IN, FOCUS_OUT], copyColorAndUpdateView);\n\n    return self;\n}","import { CHANGE, COLOR, INPUT } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { createElement, removeElement } from \"../utils/dom\";\n\n/**\n * Sliders component constants.\n */\nconst SLIDER_CLASSNAME = 'talwin__slider';\nconst HUE_SLIDER_CLASSNAME = SLIDER_CLASSNAME + ' ' + SLIDER_CLASSNAME + '--hue';\nconst ALPHA_SLIDER_CLASSNAME = SLIDER_CLASSNAME + ' ' + SLIDER_CLASSNAME + '--alpha'; \n\n/**\n * Picker sliders.\n *\n * @param {Element} parent - Element to append sliders to.\n * @param {Object} talwin - Talwin instance.\n * @returns {Object}\n */\nexport const Sliders = (parent, talwin) => {\n\n    let { _clr: { update: updateColor, value: pickerValue }, _e: { emit }} = talwin;\n\n    /**\n     * Sliders wrapper element.\n     */\n    const container = createElement('', 'tw-w100', parent);\n\n    /**\n     * Builds a slider.\n     *\n     * @param {String} className - Slider classname.\n     * @param {Number} max - Slider max value.\n     * @param {Number} step - Slider step.\n     * @returns {HTMLElement}\n     */\n    const build = (className, max, step) => \n         createElement(INPUT, className, container, { type: 'range', max, step });\n \n    /**\n     * Component API.\n     */\n    const self = {\n        /**\n         * Sliders events.\n         */\n        e: [],\n\n        hue: build(HUE_SLIDER_CLASSNAME, 360),\n        alpha: null,\n\n        /**\n         * Init. Sliders.\n         *\n         * @param {Object} options - New options.\n         */\n        init({ opacity }) {\n\n            let alpha = self.alpha;\n\n            if (opacity !== !!alpha) {\n                self.alpha = opacity ? build(ALPHA_SLIDER_CLASSNAME, 1, 0.01)\n                                     : removeElement(alpha, true) || updateColor({ a: 1 });\n            }\n        },\n\n        /**\n         * Sets sliders values.\n         *\n         * @param {Object} hsv - HSV color object.\n         */\n        val(hsv) {\n            let { alpha, hue } = self;\n            hue.value = 360 - hsv.h;\n            alpha && (alpha.value = hsv.a);\n        }\n    }\n\n    /**\n     * Handles changes in a slider value.\n     *\n     * @param {Event} e - Input or Change event.\n     */\n    const handleChange = e => {\n        let slider = e.target;\n        let value = slider.valueAsNumber;\n        let hsv = {};\n\n        if (slider === self.hue) {\n            hsv.h = 360 - value;\n        } else {\n            hsv.a = value;\n        }\n\n        updateColor(hsv);\n        // Either fire change or color event.\n        emit(e.type === CHANGE ? CHANGE : COLOR, pickerValue, slider);\n    }\n\n    /**\n     * Events binding.\n     */\n    bindEvent(self.e, container, [INPUT, CHANGE], handleChange);\n\n    return self;\n}","import { BUTTON, BUTTON_CLASSNAME, CHANGE, CLICK, COLOR, COLOR_FORMATS, ENTER, FOCUS_IN, HEX_FORMAT, INPUT, KEY_DOWN, max, SVG } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { switchSVGAttrs } from \"../lib/svg\";\nimport { createElement, removeElement, setElementsHTML, setVisibility } from \"../utils/dom\";\nimport { objectIterator } from \"../utils/object\";\n\n/**\n * Inputs constants.\n */\nconst INPUTS_CLASSNAME = 'talwin__inputs';\nconst INPUT_CLASSNAME = 'talwin__input';\nconst LABEL_CLASSNAME = 'tw-label';\n\n/**\n * Inputs component.\n *\n * @param {Element} parent - Element to append the inputs container element to.\n * @param {Object} talwin - Talwin instance.\n * @returns {Object}\n */\nexport const Inputs = (parent, talwin) => {\n\n    const { config, _clr: colorState, _e: { emit } } = talwin;\n    /**\n     * Component API.\n     */\n    const self = {};\n\n    /**\n     * Inputs wrapper element.\n     */\n    let container;\n\n    /**\n     * Switch button.\n     * @type {Element}\n     */\n    let switchButton;\n\n    /**\n     * Picker formats.\n     */\n    let formats = [];\n\n    /**\n     * Index of the current format.\n     */\n    let formatIndex;\n\n    /**\n     * Array of inputs.\n     */\n    let inputList;\n\n    /**\n     * Event listeners.\n     */\n    let listeners = [];\n\n    /**\n     * Init. Inputs.\n     *\n     * @param {Object} options - Options.\n     */\n    self.init = (options) => {\n        let { inputs, format } = options;\n        let length;\n\n        // Get only valid formats.\n        formats = COLOR_FORMATS.filter(format => inputs[format]);\n        length = formats.length;\n\n        \n        if (! length) {\n            // No input, remove inputs.\n            container = removeElement(container, true);\n            switchButton = removeElement(switchButton, true);\n            // Normalize format value.\n            format = COLOR_FORMATS.includes(format) ? format : COLOR_FORMATS[0];\n        } else {\n\n            if (! container) {\n                container = createElement('', INPUTS_CLASSNAME, parent);\n            }\n\n            if (length === 1) {\n                switchButton = removeElement(switchButton, true);\n            } else if (!switchButton) {\n                // For more than one input format, add a switch button.\n                switchButton = createElement(BUTTON, BUTTON_CLASSNAME, parent, { type: BUTTON }, (thisButton) => {\n                    createElement(SVG, '', thisButton, switchSVGAttrs);\n                });\n            }\n\n            formatIndex = max(formats.indexOf(format), 0);\n            format = formats[formatIndex];\n        }\n\n        config.format = format;\n        build(format);\n        // Show/Hide parent container.\n        setVisibility(parent, length);\n    }\n\n    /**\n     * Build Inputs.\n     */\n    const build = (format) => {\n\n        self.$ = {};\n        inputList = [];\n\n        if (container) {\n            let { singleInput, opacity } = config;\n            // Each letter in the format variable represent a color channel,\n            // For multiple inputs, each color channel has an input field.\n            // e.g. for 'rgb' format fields array is [r, g, b] or [r, g, b, a] if opacity is true.\n            let fields = singleInput || format == HEX_FORMAT ? [format]\n                        : (format + (opacity ? 'a' : '')).split('');\n\n            // Empty the container from any inputs.\n            setElementsHTML(container);\n\n            fields.forEach((field, index) => {\n                /**\n                 * Create Input.\n                 * \n                 * <label class=\"sc-label\">\n                 *     <input type=\"text\" class=\"sc-picker__input\">\n                 *     <span>${field}</span>\n                 * </label>\n                 */\n                createElement('label', LABEL_CLASSNAME, container, false, (label => {\n                    self.$[field] = inputList[index] = createElement(INPUT, INPUT_CLASSNAME, label, { type: 'text' });\n                    createElement('span', '', label, { text: field });\n                }));\n            });\n\n            colorState.update({});\n        }\n    }\n\n    /**\n     * Handles changes in inputs.\n     *\n     * @param {Event} e - Input event.\n     */\n    const handleChange = e => {\n        let value = e.target.value;\n\n        if (value.trim()) {\n            let colorString = '';\n            let format = formats[formatIndex];\n            \n            if (config.singleInput || format === HEX_FORMAT) {\n                colorString = value;\n            } else {\n                // InputList has 3 or 4 inputs, Input for each color channel in the hsl and rgb,\n                // format, the reduce method adds comma between each input value.\n                // [30, 20, 10, 0.5] => '30,20,10,0.5'\n                colorString = format + '(' + inputList.reduce((string, currentInput) => (string && string + ',') + currentInput.value, '') + ')';\n            }\n\n            if (colorState.updateByString(colorString, self)) {\n                emit(COLOR, colorState.value, self.$);\n            }\n        }\n    }\n\n    /**\n     * Changes color format.\n     *\n     * @param {Event} e - Click event.\n     */\n    const changeFormat = e => {\n        if (e.target === switchButton) {\n            // Increment input format index, reset it if it reaches the end.\n            // this index will point to the next format.\n            formatIndex = (formatIndex + 1) % formats.length;\n            config.format = formats[formatIndex];\n            build(formats[formatIndex]);\n        }\n    }\n\n    /**\n     * Triggers change event when the color changes.\n     *\n     * @param {Event} e - Focusin or Change.\n     */\n    const triggerChangeEvent = e => {\n        if (e.type === FOCUS_IN) {\n            // Save color state, when inputs receive focus.\n            colorState.start();\n        } else {\n            // Trigger change event if color state is changed.\n            colorState.end(self.$);\n        }\n    }\n\n    /**\n     * Closes picker.\n     *\n     * @param {Event} e - Keydown.\n     */\n    const closePicker = e => {\n        if (e.key === ENTER) {\n            talwin.close();\n        }\n    }\n\n    /**\n     * Updates Input(s) value(s).\n     *\n     * @param {Object} color - Color object.\n     */\n    self.val = color => {\n        objectIterator(self.$, (input, key) => {\n            input.value = color[key];\n        });\n    }\n\n    /**\n     * Bind events.\n     */\n    bindEvent(listeners, parent, CLICK, changeFormat);\n    bindEvent(listeners, parent, INPUT, handleChange);\n    bindEvent(listeners, parent, [FOCUS_IN, CHANGE], triggerChangeEvent);\n    bindEvent(listeners, parent, KEY_DOWN, closePicker);\n\n    self.e = listeners;\n\n    return self;\n}","import { BUTTON, CHANGE, CLICK, COLOR, COLOR_PROPERTY, int } from \"../constants\";\nimport { bindEvent } from \"../core/events/EventBinder\";\nimport { parseColor } from \"../lib/parser\";\nimport { createElement, getParent, removeElement, setCustomProperty, setElementsHTML, setVisibility } from \"../utils/dom\";\n\n/**\n * Swatches constants.\n */\nconst SWATCHES_CLASSNAME = 'talwin__swatches';\nconst SWATCHE_CLASSNAME = 'talwin__swatch';\n\n/**\n * Swatches component.\n *\n * @param {Element} parent - Element to append the palette element to.\n * @param {Object} talwin - Picker Instance.\n * @returns {Object}\n */\nexport const Swatches = (parent, talwin) => {\n\n    const { _clr: { value, updateByString }, _e: { emit } } = talwin;\n\n    /**\n     * Buttons wrapper element.\n     */\n    let container = createElement('', SWATCHES_CLASSNAME, parent);\n\n    /**\n     * Swatches array.\n     */\n    let swatches;\n\n    /**\n     * Creates a swatch button.\n     *\n     * @param {String} color - Swatch Color.\n     * @returns {Element}\n     */\n    const createSwatchButton = color => createElement(BUTTON, SWATCHE_CLASSNAME, container, {\n            type: BUTTON,\n        }, button => { setCustomProperty(button, COLOR_PROPERTY, parseColor(color, true)) });\n\n    /**\n     * Swatches API.\n     */\n    const self = {\n        /**\n         * Swatches events.\n         */\n        e: [],\n\n        /**\n         * Initialize swatches.\n         *\n         * @param {Object} options - Talwin options.\n         */\n        init(options) {\n            let buttons = [];\n            swatches = options.swatches;\n    \n            setVisibility(container, swatches);\n            // Empty the container from all swatch buttons.\n            setElementsHTML(container);\n    \n            swatches.forEach((color, index) => {\n                buttons[index] = createSwatchButton(color);;\n            });\n\n            self.$ = buttons;\n        },\n        /**\n         * Adds a swatch button.\n         *\n         * @param {String} color - Color.\n         */\n        add(color) {\n            let index = swatches.push(color) - 1;\n            self.$[index] = createSwatchButton(color);\n    \n            // If swatches array is empty, hide container.\n            setVisibility(container, swatches);\n        },\n        /**\n         * Removes a swatch button.\n         *\n         * @param {String|Number} swatch - Color or Swatch Index.\n         */\n        remove(swatch) {\n            let index = swatches.findIndex((color, index) => swatch === color || int(swatch) === index);\n            let swatchButtons = self.$;\n\n            if (index > -1) {\n                // Remove color from swatches array.\n                swatches.splice(index, 1);\n                // Remove swatch button.\n                removeElement(swatchButtons[index]);\n                swatchButtons.splice(index, 1);\n\n                // If swatches array is empty then hide the container.\n                setVisibility(container, swatches);\n            }\n        }\n    };\n\n    /**\n     * Sets color from a swatch button.\n     *\n     * @param {Event} e - Click.\n     */\n    const setColorFromSwatch = e => {\n        let target = e.target;\n\n        if (getParent(target) === container && updateByString(target.style.getPropertyValue('--' + COLOR_PROPERTY), true)) {\n            emit(COLOR, value, target);\n            emit(CHANGE, value, target);\n        }\n    }\n\n    /**\n     * Bind events.\n     */\n    bindEvent(self.e, parent, CLICK, setColorFromSwatch);\n\n    return self;\n}","\nimport { getElement } from \"./utils/dom\";\nimport { merge, objectIterator } from \"./utils/object\";\nimport { defaults } from \"./defaults\";\nimport { createComponents, initialize } from \"./core\";\nimport '../sass/talwin.scss';\nimport { Color } from \"./core/color\";\nimport { boundNumber, isString } from \"./utils/util\";\nimport { CHANGE, COLOR, HEX_FORMAT, HSL_FORMAT, HSV_FORMAT, RGB_FORMAT } from \"./constants\";\nimport { HSVToHSL, HSVToRGB, RGBToHEX, toString } from \"./lib/colors\";\nimport { EventListener } from \"./core/events/EventListener\";\nimport { binder } from \"./core/events/EventBinder\";\n\n\nexport default class Talwin {\n\n    /**\n     * Talwin defaults.\n     */\n    static defaults = defaults;\n\n    /**\n     * Talwin picker constructor.\n     *\n     * @param {String|Element} reference - The reference element.\n     * @param {Object} options - Options.\n     */\n    constructor(reference, options) {\n        reference = getElement(reference);\n        const talwin = this;\n        talwin.config = merge({}, Talwin.defaults, options);\n        talwin._e = EventListener(talwin);\n        talwin._clr = Color(talwin);\n        talwin._ui = createComponents(reference, talwin);\n        initialize(talwin, talwin.config);\n    }\n\n    /**\n     * Sets new options.\n     *\n     * @param {Object} options - Talwin options.\n     */\n    setOptions(options) {\n        initialize(this, options);\n    }\n\n    /**\n     * Gets the state of the picker whether it's opened or closed.\n     *\n     * @returns {Boolean}\n     */\n    isOpen() {\n        return this._ui.app.isOpen();\n    }\n\n    /**\n     * Opens the picker.\n     */\n    open() {\n        this._ui.app.open();\n    }\n\n    /**\n     * Closes the picker.\n     */\n    close() {\n        this._ui.app.close();\n    }\n\n    /**\n     * Toggles (opens/closes) the picker.\n     */\n    toggle() {\n        this._ui.app.toggle();\n    }\n\n    /**\n     * Attaches an event handler function for an event.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    on(type, handler) {\n        this._e.on(type, handler);\n    }\n\n    /**\n     * Detaches one or more event handlers.\n     *\n     * Note:\n     * omitting handler, remove all handlers from the event,\n     * omitting both event type and handler, remove all handlers that are,\n     * attached to all events.\n     *\n     * @param {String} type - Event type.\n     * @param {CallableFunction} handler - Event handler.\n     */\n    off(type, handler) {\n        this._e.off(type, handler);\n    }\n\n    /**\n     * Sets a color.\n     *\n     * @param {String|Object} color - Color.\n     */\n    setColor(color) {\n\n        let talwin = this;\n        let format;\n\n        if (! isString(color)) {\n            // Get color format from color object.\n            format = [RGB_FORMAT, HSL_FORMAT, HSV_FORMAT].find(format => format.split('')\n                                                                                   .every(channel => color[channel] && ! isNaN(color[channel])));\n            if (format) {\n                let a = color.a;\n                color.a = a != null ? a : 1;\n\n                if (format === HSV_FORMAT) {\n                    // Get current format.\n                    format = talwin.config.format;\n\n                    // H must be a value between 0 and 360.\n                    color.h = (color.h % 360 + 360) % 360;\n                    // S and V must be a value between 0 and 1.\n                    color.s = boundNumber(color.s) / 100;\n                    color.v = boundNumber(color.v) / 100;\n\n                    // Convert HSV to the selected color format.\n                    if (format === HSL_FORMAT) {\n                        color = HSVToHSL(color);\n                    } else {\n                        color = HSVToRGB(color);\n\n                        if (format === HEX_FORMAT) {\n                            color = RGBToHEX(color);\n                        }\n                    }\n                }\n                color = toString(color, format);\n            }\n        }\n\n        talwin._clr.updateByString(color, true);\n\n        return talwin;\n    }\n\n    /**\n     * Gets color.\n     *\n     * @returns {Object}\n     */\n    getColor() {\n        return this._clr.value;\n    }\n\n    /**\n     * Adds a swatch.\n     *\n     * @param {String} color - Color.\n     */\n    addSwatch(color) {\n        this._ui.swatches.add(color);\n    }\n\n    /**\n     * Removes a swatch.\n     *\n     * @param {String|Number} swatch - Can a color string or it's index in the swatches array.\n     */\n    removeSwatch(swatch) {\n        this._ui.swatches.remove(swatch);\n    }\n\n    /**\n     * Enables picker.\n     */\n    enable() {\n        this._ui.app.disable(false);\n    }\n\n    /**\n     * Disables picker.\n     */\n    disable() {\n        this._ui.app.disable(true);\n    }\n\n    /**\n     * Resets to default color.\n     */\n    reset() {\n        this.setColor(this.config.default);\n    }\n\n    /**\n     * Repositions picker if it's displayed as a popover.\n     */\n    reposition() {\n        this._ui.app.reposition();\n    }\n\n    /**\n     * Executes all handlers attached to the specified event.\n     *\n     * @param {String} type - Event type.\n     */\n    trigger(type) {\n        let talwin = this;\n        let emit = talwin._e.emit;\n\n        if (type === COLOR || type === CHANGE) {\n            emit(type, talwin._clr.value, talwin);\n        } else {\n            emit(type);\n        }\n    }\n\n    /**\n     * Destroy picker and free up memory.\n     */\n    destroy() {\n\n        let talwin = this;\n        let components = talwin._ui;\n\n        // Initialize the reference element back.\n        components.ref.init({ preset: false, toggle: true });\n\n        // Remove all events.\n        objectIterator(components, components => {\n            components.e.forEach(listener => {\n                binder(listener, true);\n            });\n        });\n\n        // Remove all properties of this instance.\n        objectIterator(talwin, (value, key) => {\n            talwin[key] = null;\n        });\n    }\n}","import { CHANGE, CLOSE, COLOR, OPEN } from \"../../constants\";\nimport { objectIterator } from \"../../utils/object\";\n\n/**\n * Picker Events.\n *\n * @returns {Object}\n */\nexport const EventListener = ({ config }) => {\n    /**\n     * Picker event listeners.\n     */\n    const listeners = {\n        [OPEN]: [],\n        [CLOSE]: [],\n        [CHANGE]: [],\n        [COLOR]: []\n    }\n\n    return {\n        /**\n         * Emits an event.\n         *\n         * @param {String} type - Event type.\n         * @param  {...any} args - Event arguments.\n         */\n        emit: (type, ...args) => {\n            if (! config.disabled && listeners[type]) {\n                listeners[type].forEach(handler => handler(...args));\n            }\n        },\n\n        /**\n         * Adds an event listener.\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        on: (type, handler) => {\n            listeners[type] && listeners[type].push(handler);\n        },\n\n        /**\n         * Remove event listener(s).\n         *\n         * @param {String} type - Event type.\n         * @param {CallableFunction} handler - Event handler.\n         */\n        off: (type, handler) => {\n            let handlersArray = listeners[type];\n\n            if (handlersArray) {\n                // Remove the handler if it's specified,\n                // Remove all handlers of this event if handler is omitted.\n                listeners[type] = handler ? handlersArray.filter(attachedHandler => attachedHandler !== handler) : [];\n            } else if (type == null) {\n                objectIterator(listeners, (handlers, type) => {\n                    listeners[type] = [];\n                });\n            }\n        }\n    }\n}","import { BODY, CHANGE, COLOR_PROPERTY, HEX_FORMAT, HSL_FORMAT, HSV_FORMAT, INPUT, RGB_FORMAT, ROOT } from \"../constants\";\nimport { HSLToHSV, HSVToHSL, HSVToRGB, RGBToHEX, RGBToHSV, toString } from \"../lib/colors\";\nimport { parseColor } from \"../lib/parser\";\nimport { createElement, removeElement, setCustomProperty } from \"../utils/dom\";\nimport { isEqual, merge, objectIterator } from \"../utils/object\";\nimport { isset } from \"../utils/util\";\n\n/**\n * Color state.\n *\n * @param {Object} talwin - Talwin instance.\n * @returns {Object}\n */\nexport const Color = (talwin) => {\n\n    let HSV = {\n        h: 0,\n        s: 0,\n        v: 0,\n        a: 1\n    }\n\n    let RGB = HSVToRGB(HSV);\n\n    let rgbString = '';\n\n    let { config, _e: event } = talwin;\n\n    let colorStart;\n\n\n    /**\n     * Updates color and UI.\n     *\n     * @param {Object} newHSV - HSV color object.\n     * @param {Object|Boolean} updater - Exclude some components from updating.\n     * @param {Object} rgb - RGB color object.\n     */\n    const update = (newHSV, updater, rgb) => {\n        if (! config.disabled) {\n            merge(HSV, newHSV);\n            RGB = rgb || HSVToRGB(HSV);\n            rgbString = toString(RGB, RGB_FORMAT);\n    \n            let components = talwin._ui;\n            let { palette, sliders, inputs } = components;\n    \n            // Preview color.\n            setCustomProperty(components.preview.$, COLOR_PROPERTY, rgbString);\n            setCustomProperty(components.ref.$, COLOR_PROPERTY, rgbString);\n            // Change the gradient color stop of the alpha slider.\n            (updater || ! isset(newHSV.a)) && setCustomProperty(sliders.alpha, RGB_FORMAT, RGB.r + ',' + RGB.g + ',' + RGB.b);\n            // Set palette's hue.\n            isset(newHSV.h) && setCustomProperty(palette.$, 'hue', HSV.h);\n    \n            if (updater !== inputs) {\n                inputs.val(getColor('', config.singleInput));\n            }\n    \n            if (updater) {\n                sliders.val(HSV);\n                palette.update(HSV);\n            }\n        }\n    }\n\n    /**\n     * Gets color object.\n     *\n     * @param {String} format - Color format.\n     * @param {Boolean} asString - Get color as a string.\n     * @returns {Object}\n     */\n    const getColor = (format, asString) => {\n        format = format || config.format;\n\n        let isHex = format === HEX_FORMAT;\n        let color = isHex ? RGBToHEX(RGB)\n                : format === HSL_FORMAT ? HSVToHSL(HSV, !asString)\n                : RGB;\n\n        return asString || isHex ? { [format]: toString(color, format) } : color;\n    }\n\n\n    /**\n     * Updates color by a string instead of HSV object.\n     *\n     * @param {String} colorString - Color string.\n     * @param {Boolean|Object} updater - Exclude some components from updating.\n     */\n    const updateByString = (colorString, updater) => {\n\n        let { c: parsedColor, f: format } = parseColor(colorString);\n        let currentColor = getColor(format);\n        let isChanged = ! isEqual(parsedColor, currentColor);\n        let rgb, hsv;\n\n        if (isChanged) {\n\n            if (format === HSL_FORMAT) {\n                hsv = HSLToHSV(parsedColor);\n            } else {\n                rgb = parsedColor;\n                hsv = RGBToHSV(parsedColor);\n            }\n\n            update(hsv, updater, rgb);\n        }\n\n        return isChanged;\n    }\n\n    /**\n     * Copies color to the clipboard.\n     *\n     * @returns {Boolean}\n     */\n    const copy = () => objectIterator(getColor('', true), color => {\n\n            let clipboard = navigator.clipboard;\n\n            if (clipboard) {\n                clipboard.writeText(color);\n            } else {\n                // Incase browser doesn't support navigator.clipboard,\n                // Create a new input element and append it to the body,\n                // set its value as the color.\n                createElement(INPUT, '', BODY, null, input => {\n\n                    input.value = color;\n                    input.select();\n                    ROOT.execCommand('copy');\n\n                    // Color text is copied so remove the input.\n                    removeElement(input);\n                });\n            }\n        });\n\n    /**\n     * Outputs a color object.\n     *\n     * @param {Object} colorObject - RGB, HSL or HSV color object.\n     * @param {String} colorString - Color string.\n     * @param {String} format - Color format.\n     * @param {Boolean} asArray - Output color values in an array.\n     * @returns {Ojbect|Array}\n     */\n    const output = (colorObject, colorString, format, asArray) => {\n        if (config.opacity) {\n            format += 'a';\n        }\n\n        let output = asArray ? [] : {};\n\n        if (format !== HSV_FORMAT) {\n            output.toString = () => colorString || toString(colorObject, format);\n        }\n\n        /**\n         * This puts colorObject values in an object or an array.\n         *\n         * @param {Object|Array} color - The output color.\n         * @param {String} channel - Color channel.\n         * @param {index} index - Array index.\n         */\n        return format.split('').reduce((color, channel, index) =>\n                (color[asArray ? index : channel] = colorObject[channel]) && color, output);\n    }\n\n    /**\n     * Picker value.\n     */\n    const value = {\n        [HSV_FORMAT]: () => output(HSV, '', HSV_FORMAT, false),\n        [RGB_FORMAT]: asArray => output(RGB, rgbString, RGB_FORMAT, asArray),\n        [HSL_FORMAT]: asArray => output(HSVToHSL(HSV), '', HSL_FORMAT, asArray),\n        [HEX_FORMAT]: () => RGBToHEX(RGB)\n    }\n\n    /**\n     * Set color start.\n     */\n    const start = () => {\n        colorStart = getColor();\n    }\n\n    /**\n     * Triggers change event if colorStart doesn't equal to the current color.\n     *\n     * @param {Element} source - Element that changed color state.\n     */\n    const end = (source) => {\n        if (! isEqual(colorStart, getColor())) {\n            event.emit(CHANGE, value, source);\n        }\n    }\n\n    return {\n        value,\n        update,\n        updateByString,\n        copy,\n        start,\n        end,\n    }\n}"],"names":["root","factory","exports","module","define","amd","self","__webpack_require__","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","ROOT","document","BODY","body","HTML","documentElement","BUTTON","SVG","OPEN","CLOSE","COLOR","CLICK","MOUSE_DOWN","SCROLL","KEY_DOWN","INPUT","CHANGE","FOCUS_IN","FOCUS_OUT","HEX_FORMAT","RGB_FORMAT","HSL_FORMAT","HSV_FORMAT","FOCUS_CLASSNAME","BUTTON_CLASSNAME","COLOR_PROPERTY","REMOVE_METHOD","COLOR_FORMATS","max","min","round","Math","float","parseFloat","int","parseInt","objectIterator","object","fn","merge","target","sources","assign","isEqual","object1","object2","value","isString","isset","boundNumber","number","upperBound","lowerBound","getElement","ref","context","all","Element","createElement","tagName","className","parent","data","callback","ns","element","createElementNS","setElementsHTML","innerText","setAttributeNS","appendChild","getBounds","el","getBoundingClientRect","getParent","parentElement","replaceElement","newChild","oldChild","replaceChild","removeElement","destroy","removeChild","setCustomProperty","property","style","setProperty","setVisibility","cond","length","display","updateClass","classname","classList","html","innerHTML","defaults","id","theme","toggle","popover","position","margin","preset","color","default","disabled","format","singleInput","inputs","rgb","hex","hsl","opacity","preview","copy","swatches","binder","eventData","unbind","method","targetElement","events","handler","options","forEach","event","bindEvent","listeners","push","unbindEvent","filter","sides","top","right","bottom","left","alignments","start","center","end","svgStaticAttrs","focusable","svgAttrs","width","height","viewBox","clipboardSVGAttrs","checkSVGAttrs","switchSVGAttrs","HSVToRGB","hsv","H","h","S","s","V","v","k","r","g","b","a","toString","colorString","comma","percent","toHex","hexNumber","RGBToHEX","HSVToHSL","percentage","l","ctx","getContext","HSL_REGEX","HEX_REGEX","parseColor","asString","trim","channels","match","angle","PI","maxAngle","slice","fillStyle","test","hexColor","split","map","c","f","createComponents","reference","talwin","createContainer","originalRef","$","e","init","type","cls","togglePicker","Reference","app","popper","config","_e","emit","_clr","colorState","_isOpen","scrollableAncestors","updatePopper","reposition","_ui","every","scrollable","isVisible","elTop","elBottom","scrollableTop","scrollableBottom","close","popperEvents","eventBinder","window","handlesAccessibility","elementToFocus","shiftKey","components","refElement","palette","contains","focusableElements","getLastFocusableElement","preventDefault","focus","update","open","silent","disable","state","targetReference","dataset","pop","refWidth","refHeight","refLeft","refTop","refBottom","refRight","refCenterX","refCenterY","popWidth","popHeight","popOffsetWidth","popOffsetHeight","docHeight","docWidth","side","alignment","popTop","popLeft","popStyle","hasSpaceForSides","hasSpaceForAlignment","isVertical","setSide","setAlignment","centerPopVertically","centerPopHorizontally","fallbacksPositions","setPosition","docBounds","clientHeight","positionSide","sidesArray","sideIsSet","alignmentIsSet","i","alignmentsArray","j","positionAlignment","scPop","scrollableElements","overflow","getComputedStyle","getScrollableAncestors","insertAdjacentElement","isOpen","App","tabindex","overlay","marker","centerX","centerY","markerX","markerY","moveTo","x","y","transform","point","Marker","WIDTH","HEIGHT","stepX","stepY","moveX","moveY","bounds","isDragging","updateColor","moveAndUpdateColor","touches","clientX","clientY","passive","blur","Palette","container","isCopied","previewArea","copyButton","cp","thisButton","updateSVG","button","isFocusIn","Preview","sliders","pickerValue","build","step","hue","SLIDER_CLASSNAME","alpha","val","slider","valueAsNumber","Sliders","switchButton","formatIndex","inputList","formats","indexOf","includes","fields","field","index","label","text","input","reduce","string","currentInput","updateByString","Inputs","createSwatchButton","buttons","add","remove","swatch","findIndex","swatchButtons","splice","getPropertyValue","Swatches","initialize","component","setColor","Talwin","constructor","this","args","on","off","handlersArray","attachedHandler","handlers","EventListener","colorStart","HSV","RGB","rgbString","newHSV","updater","getColor","isHex","output","colorObject","asArray","channel","parsedColor","currentColor","isChanged","HSLToHSV","R","G","B","Cmax","range","saturation","RGBToHSV","clipboard","navigator","writeText","select","execCommand","source","Color","setOptions","find","isNaN","addSwatch","removeSwatch","enable","reset","trigger","listener"],"sourceRoot":""}